---
title: "[Baekjoon] #18352 특정거리의 도시 찾기"
categories:	
  - CodingTest  
tags:
  - Baekjoon
  - Python3
  - Dijkstra
---

## 문제

[문제보기](https://www.acmicpc.net/problem/18352)

어떤 나라에는 1번부터 *N*번까지의 도시와 *M*개의 단방향 도로가 존재한다. 모든 도로의 거리는 1이다.

이 때 특정한 도시 *X*로부터 출발하여 도달할 수 있는 모든 도시 중에서, 최단 거리가 정확히 *K*인 모든 도시들의 번호를 출력하는 프로그램을 작성하시오. 또한 출발 도시 *X*에서 출발 도시 *X*로 가는 최단 거리는 항상 0이라고 가정한다.

예를 들어 *N*=4, *K*=2, *X*=1일 때 다음과 같이 그래프가 구성되어 있다고 가정하자.

![img](https://upload.acmicpc.net/a5e311d7-7ce4-4638-88a5-3665fb4459e5/-/preview/)

이 때 1번 도시에서 출발하여 도달할 수 있는 도시 중에서, 최단 거리가 2인 도시는 4번 도시 뿐이다.  2번과 3번 도시의 경우, 최단 거리가 1이기 때문에 출력하지 않는다.

<br>

##### 입력

첫째 줄에 도시의 개수 *N*, 도로의 개수 *M*, 거리 정보 *K*, 출발 도시의 번호 *X*가 주어진다. (2 ≤ *N* ≤ 300,000, 1 ≤ *M* ≤ 1,000,000, 1 ≤ *K* ≤ 300,000, 1 ≤ *X* ≤ *N*) 둘째 줄부터 *M*개의 줄에 걸쳐서 두 개의 자연수 *A*, *B*가 공백을 기준으로 구분되어 주어진다. 이는 *A*번 도시에서 *B*번 도시로 이동하는 단방향 도로가 존재한다는 의미다. (1 ≤ *A*, *B* ≤ *N*) 단, *A*와 *B*는 서로 다른 자연수이다.

<br>

##### 출력

*X*로부터 출발하여 도달할 수 있는 도시 중에서, 최단 거리가 *K*인 모든 도시의 번호를 한 줄에 하나씩 오름차순으로 출력한다.

이 때 도달할 수 있는 도시 중에서, 최단 거리가 *K*인 도시가 하나도 존재하지 않으면 -1을 출력한다.

<br>

##### 예제 입력 1 복사

```
4 4 2 1
1 2
1 3
2 3
2 4
```

##### 예제 출력 1 복사

```
4
```

#####  예제 입력 2 복사

```
4 3 2 1
1 2
1 3
1 4
```

#####  예제 출력 2 복사

```
-1
```

##### 예제 입력 3 복사

```
4 4 1 1
1 2
1 3
2 3
2 4
```

##### 예제 출력 3 복사

```
2
3
```

<br>

## 풀이

```
다익스트라 알고리즘에 따라 시작노드에서 특정노드까지의 최단거리를 도출한다.

다익스트라 알고리즘
1. 시작노드에 방문한 뒤, 거리를 0으로 설정한다.
2. 시작노드와 연결된 노드들 중, 아직 방문하지 않았으며 거리값이 설정되지 않은 노드를 방문한다.
3. 해당 노드들의 최단거리를 갱신한다.(기존 최단거리값과 현재까지 진행한 거리값 비교하여 갱신)
4. 다시 해당 노드에서 2~3번 과정을 통해 다음 노드를 방문하고, 최단거리를 갱신한다.(반복문)
5. 더 이상 다른 노드를 방문할 수 없게되면 반복문을 탈출한 뒤 최종 결과를 도출한다.

각 노드별 최단거리 값을 구해낸 이후, 문제에서 요구한대로 특정 거리만큼 떨어져 있는 도시들의 목록을 오름차순으로 출력한다.
```



```python
import sys

# 입력부
input = sys.stdin.readline

n, m, k, x = map(int, input().split())
roads = {i: {} for i in range(1, n+1)}
for i in range(1, m+1):
    c1, c2 = map(int, input().split())
    roads[c1][c2] = 1

# 도시별 최단거리 도출(다익스트라 알고리즘)
visited = [False for _ in range(n+1)]
distances = [sys.maxsize for _ in range(n+1)]

visited[0], visited[x] = True, True
distances[x] = 0

# x도시와 연결된 도시들의 거리 갱신
for i in roads[x]:
    distances[i] = 1

current_dist = 1
# 연결이 된 도시들의 최단거리값 갱신
while False in visited:
    cnt = 0
    for i in range(1, n+1):
        if visited[i] == False and distances[i] == current_dist:
            cnt += 1
            visited[i] = True
            for j in roads[i]:
                distances[j] = min(distances[j], current_dist+1)

    if cnt == 0:
        break

    current_dist += 1

# 조건에 맞는 도시 번호 출력
if k not in distances:
    print(-1)
else:
    for idx, i in enumerate(distances):
        if i == k:
            print(idx)

```

- 입력부에서 구동시간을 줄이기 위해 `sys.stdin.readline`를 사용했다.
  - 그냥 input을 하면 입력부에서 시간초과가 난다.
- 경로의 빠른 탐색을 위해 딕셔너리로 경로정보를 저장한다.
  - 경로가 단방향임에 주의한다.
- 최단거리를 갱신할 때, 현재진행거리 값을 저장하여 비교값으로 사용한다.
- 이 문제는 BFS로도 풀 수 있을 것이다. tree의 깊이가 곧 최단거리이기 때문이다.